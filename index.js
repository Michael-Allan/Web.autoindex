/** Presentation program for indeces of directory content
  *
  * Referent of an `IndexHeadInsert` configuration directive, this program is summoned
  * to the client side where it manipulates the DOM of each index page.
  */
( function() {


    /** Gives `node` if it is a text node, otherwise gives null.
      */
    function asText( node ) { return node.nodeType === /*Node.TEXT_NODE*/3? node : null; }



    /** @param newTitle (string)
      */
    function retitle( newTitle ) {
        let e = document.head.firstElementChild;
        if( e.localName === 'title' ) {
            let t = asText( e.firstChild );
            if( t ) t.data = newTitle; }}



    /** @param body (Element)
      */
    function run( body ) {
        let e = body.firstElementChild;
        if( e === null ) return; /* In case this program starts too quickly,
          the client having ignored its `defer` qualifier. */
        let h1Count = 0;
        let h1Generated; // The `h1` element automatically generated by `mod_autoindex`.
        if( e.localName === 'h1' && e.id === 'indextitle' ) {
            ++h1Count;
            h1Generated = e; }
        const traversal = document.createTreeWalker( body, NodeFilter.SHOW_ELEMENT );
        if( !traversal ) return; // Unsupported by client.
        let h1Declared; /* The `h1` element declared by the readme file, if any, iff `h1Count` is two.
          http://httpd.apache.org/docs/2.4/mod/mod_autoindex.html#readmename */
        for( let e = traversal.nextNode();  // Onto `body` itself, only to begin with
              e = traversal.nextNode(); ) { // its successor (if any) in document order.
            switch( e.localName ) {
                case 'table':
                    if( e.id === 'indexlist' ) {
                        const trHead = e.firstElementChild/*tbody*/.firstElementChild/*tr indexhead*/;
                        let t;

                      // Rehead the timestamp column from ‘Last modified’ to ‘Timestamp’
                      // ───────────────────────────
                        t = asText( trHead.firstElementChild/*th.indexcolicon*/
                          .nextElementSibling/*th.indexcolname*/.nextElementSibling/*th.indexcollastmod*/
                          .firstElementChild/*a*/.firstChild );
                        if( t && t.data === 'Last modified'/*as it should*/ ) t.data = 'Timestamp';

                      // Rename the parent link from ‘Parent Directory’ to ‘Parent’
                      // ──────────────────────
                        t = asText( trHead.nextElementSibling/*tr.indexbreakrow*/
                          .nextElementSibling/*tr.even*/.firstElementChild/*td.indexcolicon*/
                          .nextElementSibling/*td.indexcolname*/.firstElementChild/*a*/.firstChild );
                        if( t && t.data === 'Parent Directory'/*as it should*/ ) t.data = 'Parent';

                        traversal.lastChild(); } // Fast forwarding (near) to the end of the table.
                    continue;
                case 'h1':
                    if( !e.isSameNode( h1Generated )) {
                        ++h1Count;
                        h1Declared = e; }
                    continue; }}
        if( !h1Generated ) return;
        if( h1Count === 1 ) { // A readme file is absent.

          // Reformat the head of the document
          // ─────────────────
            let t = asText( h1Generated.firstChild );
            if( t ) {
                let head = t.data;
                if( head.startsWith( titleLeader )) { // As it should.
                    const titleRemainder = head.slice( titleLeader.length );
                    head = 'Index of `' + titleRemainder + '/`';
                    t.data = head;
                    retitle( head ); }}} // Retitling the document accordingly.
        else if( h1Count === 2 ) { // A readme file is present and `h1Declared` captures its single `h1`.

          // Move the head of the readme file in place of that generated by `mod_autoindex`
          // ─────────────
         // h1Generated.parentNode.replaceChild( h1Declared, h1Generated );
         /// rather, to retain the original attributes of `h1Generated`, transfer their children:
            while( h1Generated.hasChildNodes() ) h1Generated.removeChild( h1Generated.firstChild );
            while( h1Declared.hasChildNodes() ) h1Generated.appendChild( h1Declared.firstChild );
            h1Declared.parentNode.removeChild( h1Declared );
            retitle( h1Generated.textContent ); }} // Retitling the document accordingly.



    const titleLeader = 'Index of /'; // So starts the titles automatically generated by `mod_autoindex`.



////////////////////

    run( document.body ); }() );


                                                   // Copyright © 2017-2020  Michael Allan.  Licence MIT.
